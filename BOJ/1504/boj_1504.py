# -*- coding: utf-8 -*-
"""BOJ_1504.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14ZT5K6N3oCFAaHjIUtOx-wEghFe8VEoA
"""

import sys
import collections
import heapq

max_value = sys.maxsize

def d(graph, start):
    dist = {i:max_value for i in graph}
    dist[start] = 0
    Q = []
    heapq.heappush(Q, [dist[start], start])

    while Q:
        cur_dist, curr = heapq.heappop(Q)
        if cur_dist > dist[curr] :
            continue
        for new_start, new_dist in graph[curr]:
            distance = cur_dist + new_dist
            if distance < dist[new_start]:
                dist[new_start] = distance
                heapq.heappush(Q, [distance, new_start])
    return dist



N, E = map(int, input().split())
if E == 0:
    print(-1)
    sys.exit(0)
graph = collections.defaultdict(list)


# 전체 경로 저장
for i in range(E):
    a,b,c = map(int, input().split())
    graph[a].append([b,c])
    graph[b].append([a,c])

# 필수로 거쳐야 하는 정점
v1, v2 = map(int, input().split())

v1_dist = d(graph, v1)
v2_dist = d(graph, v2)

result1 = v1_dist[1] + v1_dist[v2] + v2_dist[N]
result2 = v2_dist[1] + v2_dist[v1] + v1_dist[N]
result = min(result1, result2)

if result1 >= max_value:
    print(-1)
else:
    print(result)