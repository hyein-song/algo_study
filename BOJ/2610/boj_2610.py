# -*- coding: utf-8 -*-
"""BOJ_2610.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RGy6t-e9lTjcJ1qaNxQDrScY7NFeU-N1
"""

import sys
import collections
# input = sys.stdin.readline
max_val = sys.maxsize

n = int(input())
m = int(input())

graph = [[max_val for _ in range(n+1)]for _ in range(n+1)]
g2 = collections.defaultdict(list)

for i in range(1,n+1):
    graph[i][i] = 0

for i in range(m):
    a, b = map(int, input().split())
    graph[a][b] = 1
    graph[b][a] = 1
    g2[a].append(b)
    g2[b].append(a)

for k in range(1,n+1):
    for i in range(1,n+1):
        for j in range(1,n+1):
            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])

Q = collections.deque()
Q.append(1)
v = [i for i in range(2,n+1)]
cnt = 0
lower = {}
tmp = []

while Q:
    x = Q.popleft()
    
    sum_x = [i for i in graph[x] if i != max_val]
    lower[x]= max(sum_x)


    for k in g2[x]:
        if k in v:
            Q.append(k)
            v.remove(k)

    if not Q:
        min_index = x
        min = sys.maxsize
        for key, value in lower.items():
            if value > 0 and min > value:
                min = value
                min_index = key

        tmp.append(min_index)
        lower = {}
        
        cnt += 1

        if v:
            Q.append(v[0])
            v.remove(v[0])


print(cnt)
tmp.sort()
for i in tmp:
    print(i)

import sys
import collections
import heapq
input = sys.stdin.readline
max_val = sys.maxsize

# union find
def find_parent(parent, x):
    if parent[x] == x:
        return x
    else:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union(parent, a,b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

n = int(input())
m = int(input())
parent = [i for i in range(n+1)]

graph = [[max_val for _ in range(n+1)]for _ in range(n+1)]

for i in range(1,n+1):
    graph[i][i] = 0

for i in range(m):
    a, b = map(int, input().split())
    graph[a][b] = 1
    graph[b][a] = 1
    union(parent, a,b)

for k in range(1,n+1):
    for i in range(1,n+1):
        for j in range(1,n+1):
            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])

# group 찾기
group_min_dict = dict()

for i in range(1,n+1):
    p = find_parent(parent, i)
    max_i = max([j for j in graph[i] if j!= max_val])
    if p in group_min_dict:
        if group_min_dict[p][1] > max_i:
            group_min_dict[p] = [i, max_i]
    else:
        group_min_dict[p] = [i, max_i]

Q = []
for index, val in group_min_dict.values():
    heapq.heappush(Q, index)

print(len(Q))
while Q:
    print(heapq.heappop(Q))